package com.github.lolgab.jdbc.sqlite

import java.sql.*
import com.github.lolgab.jdbc.sqlite.internal.SQLiteOps
import com.github.lolgab.jdbc.sqlite.internal.constants.*
import com.github.lolgab.jdbc.sqlite.internal.structs.*
import com.github.lolgab.jdbc.sqlite.internal.functions.*
import scala.scalanative.unsafe.*
import java.util.concurrent.Executor
import java.{util => ju}

class SQLiteConnection(filename: String) extends Connection {

  override def createStruct(
      typeName: String,
      attributes: scala.Array[Object]
  ): Struct = ???

  override def setTypeMap(map: ju.Map[String, Class[?]]): Unit = ???

  override def getClientInfo(name: String): String = ???

  override def getClientInfo(): ju.Properties = ???

  override def prepareCall(sql: String): CallableStatement = ???

  override def prepareCall(
      sql: String,
      resultSetType: Int,
      resultSetConcurrency: Int
  ): CallableStatement = ???

  override def prepareCall(
      sql: String,
      resultSetType: Int,
      resultSetConcurrency: Int,
      resultSetHoldability: Int
  ): CallableStatement = ???

  override def createClob(): Clob = ???

  override def setHoldability(holdability: Int): Unit = ???

  override def createStatement(
      resultSetType: Int,
      resultSetConcurrency: Int
  ): Statement = ???

  override def createStatement(
      resultSetType: Int,
      resultSetConcurrency: Int,
      resultSetHoldability: Int
  ): Statement = ???

  override def getHoldability(): Int = ???

  override def getNetworkTimeout(): Int = ???

  override def clearWarnings(): Unit = ???

  override def createNClob(): NClob = ???

  override def setClientInfo(name: String, value: String): Unit = ???

  override def setClientInfo(properties: ju.Properties): Unit = ???

  override def abort(executor: Executor): Unit = ???

  override def getCatalog(): String = ???

  override def createArrayOf(
      typeName: String,
      elements: scala.Array[Object]
  ): Array = ???

  override def getTypeMap(): ju.Map[String, Class[?]] = ???

  override def rollback(savepoint: Savepoint): Unit = ???

  override def isValid(timeout: Int): Boolean = ???

  override def setReadOnly(readOnly: Boolean): Unit = ???

  override def nativeSQL(sql: String): String = ???

  override def setCatalog(catalog: String): Unit = ???

  override def getMetaData(): DatabaseMetaData = ???

  override def getSchema(): String = ???

  override def createSQLXML(): SQLXML = ???

  override def createBlob(): Blob = ???

  override def getWarnings(): SQLWarning = ???

  override def setNetworkTimeout(executor: Executor, milliseconds: Int): Unit =
    ???

  override def setSchema(schema: String): Unit = ???

  override def prepareStatement(
      sql: String,
      resultSetType: Int,
      resultSetConcurrency: Int
  ): PreparedStatement = ???

  override def prepareStatement(
      sql: String,
      resultSetType: Int,
      resultSetConcurrency: Int,
      resultSetHoldability: Int
  ): PreparedStatement = ???

  override def prepareStatement(
      sql: String,
      autoGeneratedKeys: Int
  ): PreparedStatement = ???

  override def prepareStatement(
      sql: String,
      columnIndexes: scala.Array[Int]
  ): PreparedStatement = ???

  override def prepareStatement(
      sql: String,
      columnNames: scala.Array[String]
  ): PreparedStatement = ???

  override def isReadOnly(): Boolean = ???

  override def unwrap[T](iface: Class[T]): T = ???

  override def isWrapperFor(iface: Class[?]): Boolean = ???

  private var db: Ptr[sqlite3] = null
  private var closed = false
  private var autoCommit = true

  locally {
    Zone {
      val dbPtr = alloc[Ptr[sqlite3]]()
      val result = sqlite3_open(toCString(filename), dbPtr)
      if (result != SQLITE_OK) {
        throw SQLException(s"Failed to open database: $filename")
      }
      db = !dbPtr
    }
  }

  override def createStatement(): Statement = {
    checkClosed()
    SQLiteStatement(this, db)
  }

  override def prepareStatement(sql: String): PreparedStatement = {
    checkClosed()
    SQLitePreparedStatement(this, db, sql)
  }

  override def setAutoCommit(autoCommit: Boolean): Unit = {
    checkClosed()
    if (this.autoCommit != autoCommit) {
      executeSimpleStatement(if (autoCommit) "COMMIT" else "BEGIN")
      this.autoCommit = autoCommit
    }
  }

  override def getAutoCommit(): Boolean = {
    checkClosed()
    autoCommit
  }

  override def commit(): Unit = {
    checkClosed()
    if (!autoCommit) {
      executeSimpleStatement("COMMIT")
      executeSimpleStatement("BEGIN")
    }
  }

  override def rollback(): Unit = {
    checkClosed()
    if (!autoCommit) {
      executeSimpleStatement("ROLLBACK")
      executeSimpleStatement("BEGIN")
    }
  }

  override def close(): Unit = {
    if (!closed) {
      if (!autoCommit) {
        try {
          rollback()
        } catch {
          case _: SQLException => // Ignore
        }
      }
      sqlite3_close_v2(db)
      closed = true
      db = null
    }
  }

  override def isClosed(): Boolean = closed

  override def setSavepoint(): Savepoint = {
    checkClosed()
    if (autoCommit) {
      throw SQLException("Cannot set savepoint in auto-commit mode")
    }
    val id = savepointCounter.getAndIncrement()
    val name = s"SAVEPOINT_$id"
    executeSimpleStatement(s"SAVEPOINT $name")
    SQLiteSavepoint(id, name)
  }

  override def setSavepoint(name: String): Savepoint = {
    checkClosed()
    if (autoCommit) {
      throw SQLException("Cannot set savepoint in auto-commit mode")
    }
    executeSimpleStatement(s"SAVEPOINT $name")
    SQLiteSavepoint(-1, name)
  }

  override def releaseSavepoint(savepoint: Savepoint): Unit = {
    checkClosed()
    if (autoCommit) {
      throw SQLException("Cannot release savepoint in auto-commit mode")
    }
    executeSimpleStatement(s"RELEASE SAVEPOINT ${savepoint.getSavepointName}")
  }

  override def getTransactionIsolation(): Int = {
    checkClosed()
    Connection.TRANSACTION_SERIALIZABLE // SQLite only supports serializable transactions
  }

  override def setTransactionIsolation(level: Int): Unit = {
    checkClosed()
    if (level != Connection.TRANSACTION_SERIALIZABLE) {
      throw SQLException("SQLite only supports TRANSACTION_SERIALIZABLE")
    }
  }

  private def checkClosed(): Unit = {
    if (closed) {
      throw SQLException("Connection is closed")
    }
  }

  private def executeSimpleStatement(sql: String): Unit = {
    Zone {
      SQLiteOps.withStatement(db, sql) { stmt =>
        val result = sqlite3_step(stmt)
        if (result != SQLITE_DONE) {
          throw SQLiteOps.sqliteException(db, s"Failed to execute statement: $sql")
        }
      }
    }
  }

  private object savepointCounter {
    private var counter = 0
    def getAndIncrement(): Int = {
      val current = counter
      counter += 1
      current
    }
  }
}

class SQLiteSavepoint(id: Int, name: String) extends Savepoint {
  override def getSavepointId(): Int = {
    if (id < 0) throw SQLException("Named savepoint does not have an ID")
    id
  }

  override def getSavepointName(): String = name
}
