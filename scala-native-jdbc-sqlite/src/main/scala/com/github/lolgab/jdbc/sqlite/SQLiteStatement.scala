package com.github.lolgab.jdbc.sqlite

import java.sql.{Statement, ResultSet, SQLException}
import com.github.lolgab.jdbc.sqlite.internal.*
import com.github.lolgab.jdbc.sqlite.internal.constants.*
import com.github.lolgab.jdbc.sqlite.internal.structs.*
import com.github.lolgab.jdbc.sqlite.internal.functions.*
import scala.scalanative.unsafe.*
import scala.scalanative.unsigned.*
import java.sql.SQLWarning
import java.sql.Connection

class SQLiteStatement(
    connection: SQLiteConnection,
    db: Ptr[sqlite3]
) extends Statement {

  private var generatedKeysStatement: Statement = null
  private var generatedKeysResultSet: ResultSet = null

  override def execute(sql: String, columnIndexes: Array[Int]): Boolean = ???

  override def execute(sql: String, columnNames: Array[String]): Boolean = ???

  override def getFetchDirection(): Int = ???

  override def getMoreResults(current: Int): Boolean = ???

  override def executeBatch(): Array[Int] = ???

  override def setFetchDirection(direction: Int): Unit = ???

  override def clearWarnings(): Unit = ???

  override def executeUpdate(sql: String, columnIndexes: Array[Int]): Int = ???

  override def executeUpdate(sql: String, columnNames: Array[String]): Int = ???

  override def clearBatch(): Unit = ???

  override def getFetchSize(): Int = ???

  override def setFetchSize(rows: Int): Unit = ???

  override def getResultSetConcurrency(): Int = ???

  override def getResultSetType(): Int = ???

  override def isPoolable(): Boolean = ???

  override def closeOnCompletion(): Unit = ???

  override def setEscapeProcessing(enable: Boolean): Unit = ???

  override def setMaxFieldSize(max: Int): Unit = ???

  override def getMaxFieldSize(): Int = ???

  override def getConnection(): Connection = ???

  override def getResultSetHoldability(): Int = ???

  override def addBatch(sql: String): Unit = ???

  def clearGeneratedKeys(): Unit = {
    if (generatedKeysResultSet != null && !generatedKeysResultSet.isClosed()) {
      generatedKeysResultSet.close()
    }
    generatedKeysResultSet = null

    if (generatedKeysStatement != null && !generatedKeysStatement.isClosed()) {
      generatedKeysStatement.close()
    }
    generatedKeysStatement = null
  }

  protected def updateGeneratedKeys(autoGeneratedKeys: Int): Unit = {
    if (autoGeneratedKeys == Statement.RETURN_GENERATED_KEYS) {
      clearGeneratedKeys()
      generatedKeysStatement = connection.createStatement()
      generatedKeysResultSet =
        generatedKeysStatement.executeQuery("SELECT last_insert_rowid();")
    }
  }
  override def getGeneratedKeys(): ResultSet = {
    if (generatedKeysResultSet == null) {
      generatedKeysStatement = connection.createStatement()
      generatedKeysResultSet =
        generatedKeysStatement.executeQuery("SELECT 1 WHERE FALSE;")
    }
    generatedKeysResultSet
  }

  override def setCursorName(name: String): Unit = ???

  override def getWarnings(): SQLWarning = ???

  override def isCloseOnCompletion(): Boolean = ???

  override def setPoolable(poolable: Boolean): Unit = ???

  override def unwrap[T](iface: Class[T]): T = ???

  override def isWrapperFor(iface: Class[?]): Boolean = ???

  private var currentResultSet: SQLiteResultSet = null
  private var closed = false
  private var maxRows = 0
  private var queryTimeout = 0

  override def executeQuery(sql: String): ResultSet = {
    checkClosed()
    closeCurrentResultSet()

    currentResultSet = Zone {
      val stmt = SQLiteOps.createStatementHandle(db, sql)
      SQLiteResultSet(this, db, stmt)
    }

    currentResultSet
  }

  override def executeUpdate(sql: String): Int =
    executeUpdate(sql, autoGeneratedKeys = Statement.NO_GENERATED_KEYS)

  override def executeUpdate(sql: String, autoGeneratedKeys: Int): Int = {
    checkClosed()
    closeCurrentResultSet()

    val result = Zone {
      SQLiteOps.withStatement(db, sql) { stmt =>
        val result = sqlite3_step(stmt)
        if (result != SQLITE_DONE) {
          SQLiteOps.sqliteException(db, s"Failed to execute update: $sql")
        }

        sqlite3_changes(db)
      }
    }

    updateGeneratedKeys(autoGeneratedKeys)

    result
  }

  override def execute(sql: String): Boolean =
    execute(sql, Statement.NO_GENERATED_KEYS)

  override def execute(sql: String, autoGeneratedKeys: Int): Boolean = {
    checkClosed()
    closeCurrentResultSet()

    val result = Zone {
      SQLiteOps.withStatement(db, sql) { stmt =>
        val result = sqlite3_step(stmt)
        result == SQLITE_ROW
      }
    }
    updateGeneratedKeys(autoGeneratedKeys)
    result
  }

  override def getResultSet(): ResultSet = {
    checkClosed()
    currentResultSet
  }

  override def getUpdateCount(): Int = {
    checkClosed()
    -1 // No current update count available
  }

  override def getMoreResults(): Boolean = {
    checkClosed()
    closeCurrentResultSet()
    false // SQLite doesn't support multiple result sets
  }

  override def close(): Unit = {
    if (!closed) {
      closeCurrentResultSet()
      closed = true
    }
  }

  override def setMaxRows(max: Int): Unit = {
    checkClosed()
    if (max < 0) {
      throw SQLException("Max rows must be >= 0")
    }
    maxRows = max
  }

  override def getMaxRows(): Int = {
    checkClosed()
    maxRows
  }

  override def setQueryTimeout(seconds: Int): Unit = {
    checkClosed()
    if (seconds < 0) {
      throw SQLException("Query timeout must be >= 0")
    }
    queryTimeout = seconds
    // Note: SQLite doesn't have a direct way to set query timeout
    // We would need to implement this using progress callbacks
  }

  override def getQueryTimeout(): Int = {
    checkClosed()
    queryTimeout
  }

  override def cancel(): Unit = {
    checkClosed()
    // SQLite doesn't support canceling queries
    throw SQLException("Cancel not supported")
  }

  override def isClosed(): Boolean = closed

  protected def checkClosed(): Unit = {
    if (closed) {
      throw SQLException("Statement is closed")
    }
  }

  private def closeCurrentResultSet(): Unit = {
    if (currentResultSet != null) {
      currentResultSet.close()
      currentResultSet = null
    }
  }
}
