package com.github.lolgab.jdbc.duckdb

import java.sql.*
import com.github.lolgab.jdbc.duckdb.internal.duckdb.all.*
import scala.scalanative.unsafe.*
import scala.scalanative.libc.stdlib.*
import java.util.concurrent.Executor
import java.{util => ju}

class DuckDBConnection(filename: String) extends Connection {

  override def createStruct(
      typeName: String,
      attributes: scala.Array[Object]
  ): Struct = ???

  override def setTypeMap(map: ju.Map[String, Class[?]]): Unit = ???

  override def getClientInfo(name: String): String = ???

  override def getClientInfo(): ju.Properties = ???

  override def prepareCall(sql: String): CallableStatement = ???

  override def prepareCall(
      sql: String,
      resultSetType: Int,
      resultSetConcurrency: Int
  ): CallableStatement = ???

  override def prepareCall(
      sql: String,
      resultSetType: Int,
      resultSetConcurrency: Int,
      resultSetHoldability: Int
  ): CallableStatement = ???

  override def createClob(): Clob = ???

  override def setHoldability(holdability: Int): Unit = ???

  override def createStatement(
      resultSetType: Int,
      resultSetConcurrency: Int
  ): Statement = ???

  override def createStatement(
      resultSetType: Int,
      resultSetConcurrency: Int,
      resultSetHoldability: Int
  ): Statement = ???

  override def getHoldability(): Int = ???

  override def getNetworkTimeout(): Int = ???

  override def clearWarnings(): Unit = ???

  override def createNClob(): NClob = ???

  override def setClientInfo(name: String, value: String): Unit = ???

  override def setClientInfo(properties: ju.Properties): Unit = ???

  override def abort(executor: Executor): Unit = ???

  override def getCatalog(): String = ???

  override def createArrayOf(
      typeName: String,
      elements: scala.Array[Object]
  ): Array = ???

  override def getTypeMap(): ju.Map[String, Class[?]] = ???

  override def rollback(savepoint: Savepoint): Unit = ???

  override def isValid(timeout: Int): Boolean = ???

  override def setReadOnly(readOnly: Boolean): Unit = ???

  override def nativeSQL(sql: String): String = ???

  override def setCatalog(catalog: String): Unit = ???

  override def getMetaData(): DatabaseMetaData = ???

  override def getSchema(): String = ???

  override def createSQLXML(): SQLXML = ???

  override def createBlob(): Blob = ???

  override def getWarnings(): SQLWarning = ???

  override def setNetworkTimeout(executor: Executor, milliseconds: Int): Unit =
    ???

  override def setSchema(schema: String): Unit = ???

  override def prepareStatement(
      sql: String,
      resultSetType: Int,
      resultSetConcurrency: Int
  ): PreparedStatement = ???

  override def prepareStatement(
      sql: String,
      resultSetType: Int,
      resultSetConcurrency: Int,
      resultSetHoldability: Int
  ): PreparedStatement = ???

  override def prepareStatement(
      sql: String,
      autoGeneratedKeys: Int
  ): PreparedStatement = ???

  override def prepareStatement(
      sql: String,
      columnIndexes: scala.Array[Int]
  ): PreparedStatement = ???

  override def prepareStatement(
      sql: String,
      columnNames: scala.Array[String]
  ): PreparedStatement = ???

  override def isReadOnly(): Boolean = ???

  override def unwrap[T](iface: Class[T]): T = ???

  override def isWrapperFor(iface: Class[?]): Boolean = ???

  private var db: Ptr[duckdb_database] = null
  private var conn: Ptr[duckdb_connection] = null
  private var closed = false
  private var autoCommit = true

  locally {
    Zone {
      val dbPtr = malloc(sizeof[duckdb_database]).asInstanceOf[Ptr[duckdb_database]]
      val dbResult =
        if (filename.isEmpty) duckdb_open(null, dbPtr)
        else duckdb_open(toCString(filename), dbPtr)
      if (dbResult == duckdb_state.DuckDBError) {
        free(dbPtr)
        throw SQLException(s"Failed to open database: $filename")
      }
      db = dbPtr
      val connPtr = malloc(sizeof[duckdb_connection]).asInstanceOf[Ptr[duckdb_connection]]
      val connResult = duckdb_connect(!db, connPtr)
      if (connResult == duckdb_state.DuckDBError) {
        free(connPtr)
        throw SQLException(s"Failed to open connection: $filename")
      }
      conn = connPtr
    }
  }

  override def createStatement(): Statement = {
    checkClosed()
    DuckDBStatement(this, conn)
  }

  override def prepareStatement(sql: String): PreparedStatement = {
    checkClosed()
    DuckDBPreparedStatement(this, conn, sql)
  }

  override def setAutoCommit(autoCommit: Boolean): Unit = {
    checkClosed()
    if (this.autoCommit != autoCommit) {
      executeSimpleStatement(if (autoCommit) "COMMIT" else "BEGIN")
      this.autoCommit = autoCommit
    }
  }

  override def getAutoCommit(): Boolean = {
    checkClosed()
    autoCommit
  }

  override def commit(): Unit = {
    checkClosed()
    if (!autoCommit) {
      executeSimpleStatement("COMMIT")
      executeSimpleStatement("BEGIN")
    }
  }

  override def rollback(): Unit = {
    checkClosed()
    if (!autoCommit) {
      executeSimpleStatement("ROLLBACK")
      executeSimpleStatement("BEGIN")
    }
  }

  override def close(): Unit = {
    if (!closed) {
      if (!autoCommit) {
        try {
          rollback()
        } catch {
          case _: SQLException => // Ignore
        }
      }
      duckdb_disconnect(conn)
      duckdb_close(db)
      closed = true
      conn = null
      db = null
    }
  }

  override def isClosed(): Boolean = closed

  override def setSavepoint(): Savepoint = {
    checkClosed()
    if (autoCommit) {
      throw SQLException("Cannot set savepoint in auto-commit mode")
    }
    val id = savepointCounter.getAndIncrement()
    val name = s"SAVEPOINT_$id"
    executeSimpleStatement(s"SAVEPOINT $name")
    DuckDBSavepoint(id, name)
  }

  override def setSavepoint(name: String): Savepoint = {
    checkClosed()
    if (autoCommit) {
      throw SQLException("Cannot set savepoint in auto-commit mode")
    }
    executeSimpleStatement(s"SAVEPOINT $name")
    DuckDBSavepoint(-1, name)
  }

  override def releaseSavepoint(savepoint: Savepoint): Unit = {
    checkClosed()
    if (autoCommit) {
      throw SQLException("Cannot release savepoint in auto-commit mode")
    }
    executeSimpleStatement(s"RELEASE SAVEPOINT ${savepoint.getSavepointName}")
  }

  override def getTransactionIsolation(): Int = {
    checkClosed()
    Connection.TRANSACTION_SERIALIZABLE // DuckDB only supports serializable transactions
  }

  override def setTransactionIsolation(level: Int): Unit = {
    checkClosed()
    if (level != Connection.TRANSACTION_SERIALIZABLE) {
      throw SQLException("DuckDB only supports TRANSACTION_SERIALIZABLE")
    }
  }

  private def checkClosed(): Unit = {
    if (closed) {
      throw SQLException("Connection is closed")
    }
  }

  private def executeSimpleStatement(sql: String): Unit = {
    if (createStatement().execute(sql) == false)
      throw SQLException(s"Failed to execute statement: $sql")
  }

  private object savepointCounter {
    private var counter = 0
    def getAndIncrement(): Int = {
      val current = counter
      counter += 1
      current
    }
  }
}

class DuckDBSavepoint(id: Int, name: String) extends Savepoint {
  override def getSavepointId(): Int = {
    if (id < 0) throw SQLException("Named savepoint does not have an ID")
    id
  }

  override def getSavepointName(): String = name
}
